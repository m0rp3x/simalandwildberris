@page "/balance-update-settings"
@using Shared
@using Shared.Enums

@inject HttpClient Http
@inject ISnackbar Snackbar

@implements IAsyncDisposable

<PageTitle>Настройки обновления баланса</PageTitle>

<MudPaper Class="pa-6 mx-auto mt-8" Style="max-width:600px;" Elevation="4">
    <MudStack Spacing="3">
        <MudText Typo="Typo.h5">⚙️ Автообновление остатков</MudText>

        <MudForm>
            <MudSwitch T="bool" @bind-Value="_enabled"
                       Label="Авто-обновление баланса"
                       Disabled="@(!_initialized)" />

            <MudButton OnClick="SaveSettings"
                       Variant="Variant.Filled"
                       Color="Color.Primary"
                       Disabled="@(!_initialized)">
                Сохранить
            </MudButton>
        </MudForm>

        <MudDivider Class="my-4" />

        <MudText Typo="Typo.h5">🗑 Обнулить остатки</MudText>

        <!-- Выбор аккаунта -->
        <MudSelect T="ExternalAccount"
                   @bind-Value="_selectedAccount"
                   Label="Выберите аккаунт"
                   Variant="Variant.Outlined"
                   FullWidth
                   Disabled="!_initialized">
            @foreach (var acct in _accounts)
            {
            <MudSelectItem Value="acct">@acct.Name</MudSelectItem>
            }
        </MudSelect>

        <MudButton OnClick="ResetBalances"
                   Variant="Variant.Outlined"
                   Color="Color.Error"
                   Disabled="!_initialized || _selectedAccount == null">
            Обнулить остатки
        </MudButton>
        <MudDivider Class="my-6" />
        <MudText Typo="Typo.h5">📊 Результаты последнего обновления</MudText>
        @if (_schedulerResults != null && _schedulerResults.Any())
        {
        <MudExpansionPanels>
            @foreach (var kvp in _schedulerResults)
            {
            <MudExpansionPanel Text="@($"Правило {kvp.Key} ({kvp.Value.Count} товаров)")">
            <MudList T="ProductInfo" Dense="true">
                @foreach (var pi in kvp.Value)
                {
                <MudListItem>
                    <b>SID:</b> @pi.Sid,
                    <b>Баланс:</b> @pi.Balance,
                    <b>MinQty:</b> @pi.qty_multiplier
                </MudListItem>
                }
            </MudList>
            </MudExpansionPanel>
            }
        </MudExpansionPanels>
        }
        else
        {
        <MudText Color="Color.Secondary">Пока нет результатов.</MudText>
        }
    </MudStack>
</MudPaper>

@code {
    private bool _initialized;
    private bool _enabled;
        
    private List<ExternalAccount> _accounts = new();
    private ExternalAccount? _selectedAccount;

    private Dictionary<int, List<ProductInfo>> _schedulerResults = new();


    private PeriodicTimer? _timer;
    private CancellationTokenSource? _pollCts;
    
    protected override async Task OnInitializedAsync()
    {
        if (!OperatingSystem.IsBrowser()){
            return;
        }
        var resp = await Http.GetFromJsonAsync<Dictionary<string, bool>>("api/scheduler/balance-enabled");
        if (resp != null && resp.TryGetValue("enabled", out var e))
            _enabled = e;
        _initialized = true;
        
        var all = await Http.GetFromJsonAsync<List<ExternalAccount>>("api/accounts")
                  ?? new List<ExternalAccount>();
        _accounts = all
            .Where(x => x.Platform == ExternalAccountType.Wildberries.ToString())
            .ToList();
        
        await LoadSchedulerResultsAsync();
        StartPollingResults();
        
        StateHasChanged();
    }
    
    private async Task ResetBalances()
    {
        if (_selectedAccount == null) return;

        var resp = await Http.PostAsync(
            $"api/scheduler/balance-reset/{_selectedAccount.Id}",
            null
        );
        if (resp.IsSuccessStatusCode)
        {
            var result = await resp.Content.ReadFromJsonAsync<Dictionary<string, int>>();
            var count = result?.GetValueOrDefault("resetCount") ?? 0;
            Snackbar.Add(
                $"Остатки по аккаунту «{_selectedAccount.Name}» обнулены: {count} товаров.",
                Severity.Success
            );
        }
        else
        {
            Snackbar.Add($"Не удалось обнулить: {resp.StatusCode}", Severity.Error);
        }
    }

    private async Task SaveSettings()
    {
        var response = await Http.PostAsJsonAsync("api/scheduler/balance-enabled", _enabled);
        if (response.IsSuccessStatusCode)
        {
            var statusText = _enabled ? "включено" : "отключено";
            Snackbar.Add($"Авто-обновление остатков {statusText}.", Severity.Success);
        }
        else
        {
            Snackbar.Add($"Ошибка при сохранении: {response.StatusCode}", Severity.Error);
        }
    }
    
    private async Task LoadSchedulerResultsAsync()
    {
        try
        {
            var results = await Http.GetFromJsonAsync<Dictionary<int, List<ProductInfo>>>(
                "api/scheduler/results");
            if (results != null)
            {
                // если появились новые
                if (!DictionaryEquals(_schedulerResults, results))
                    Snackbar.Add($"Найдены результаты обновления для {results.Count} правил", Severity.Info);

                _schedulerResults = results;
            }
            else
            {
                _schedulerResults.Clear();
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Ошибка при загрузке результатов: {ex}");
        }
    }
    
    private void StartPollingResults()
    {
        _pollCts = new CancellationTokenSource();
        _timer = new PeriodicTimer(TimeSpan.FromMinutes(1));

        // fire-and-forget loop
        _ = Task.Run(async () =>
        {
            try
            {
                while (await _timer!.WaitForNextTickAsync(_pollCts.Token))
                {
                    // в UI-потоке
                    await InvokeAsync(async () =>
                    {
                        await LoadSchedulerResultsAsync();
                        StateHasChanged();
                    });
                }
            }
            catch (OperationCanceledException) { }
        });
    }
    
    private bool DictionaryEquals(
        Dictionary<int, List<ProductInfo>> oldD,
        Dictionary<int, List<ProductInfo>> newD)
    {
        if (oldD.Count != newD.Count) return false;
        foreach (var kvp in newD)
        {
            if (!oldD.TryGetValue(kvp.Key, out var list)) return false;
            if (list.Count != kvp.Value.Count) return false;
        }
        return true;
    }
    
    public async ValueTask DisposeAsync()
    {
        _pollCts?.Cancel();
        _timer?.Dispose();
        await Task.CompletedTask;
    }
}